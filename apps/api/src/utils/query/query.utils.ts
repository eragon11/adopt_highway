import { createPaginationObject } from 'nestjs-typeorm-paginate';
import { ReportOptions } from 'src/reports/utils/report.utils';
import { Connection } from 'typeorm';

/**
 * Utility functions, types, and interface for running raw SQL queries with a typeorm {Connection} object.
 */

/**
 * interface for creating a GroupTypeInfoReport query
 */
export interface SqlClauses {
    select: Map<string, string>;
    from: Map<string, string>;
    where: Map<string, string>;
    groupBy: Map<string, string>;
    orderBy: Map<string, string>;
}

/**
 * Converts a SqClausesMap into SQL
 * @param reportOptions
 * @returns
 */
export function ParseGroupTypeReportSqlClausesToSql(
    sqlClausesMap: SqlClauses,
): string {
    let sql = '';

    // concatenate our arrays of query clauses
    if (sqlClausesMap.select.size > 0) {
        sql += `SELECT ${Array.from(sqlClausesMap.select.values()).join(',')}`;
    }
    if (sqlClausesMap.from.size > 0) {
        sql += ` FROM ${Array.from(sqlClausesMap.from.values()).join(' ')}`;
    }
    if (sqlClausesMap.from.size > 0) {
        sql += ` WHERE ${Array.from(sqlClausesMap.where.values()).join(' ')}`;
    }
    if (sqlClausesMap.groupBy.size > 0) {
        sql += ` GROUP BY ${Array.from(sqlClausesMap.groupBy.values()).join(
            ', ',
        )}`;
    }
    return sql;
}

/**
 * Orders the SQL generated by a SqlClauses function
 * @param sqlFunction Function that creates a SqlClauses object
 * @param sqlClauses
 * @param reportOptions
 * @returns {string} an ordered group type info sql query
 */
export function CreateOrderedSql(
    sqlFunction: (
        sqlClauses: SqlClauses,
        reportOptions: ReportOptions,
    ) => string,
    sqlClauses: SqlClauses,
    reportOptions: ReportOptions,
): string {
    let sql = sqlFunction(sqlClauses, reportOptions);
    if (sqlClauses.orderBy.size > 0) {
        sql += ` ORDER BY ${Array.from(sqlClauses.orderBy.values()).join(
            ', ',
        )}`;
    }
    return sql;
}

/**
 * Appends pagination SQL to a SQL statement
 * @param reportOptions
 * @returns {string} SQL query with offset and fetch next SQL
 */
export function AppendPaginationOffsetToSql(
    sql: string,
    page: number,
    limit: number,
): string {
    // append pagination SQL for current page
    const offset = limit * (page - 1);
    return `${sql} OFFSET ${offset} ROWS FETCH NEXT ${limit} ROWS ONLY`;
}

/**
 * For returning the total count of a SQL query to be used in pagination metadata
 * @param connection
 * @param sql
 * @returns the total count of the query
 */
export async function GetTotalCount(
    connection: Connection,
    sql: string,
): Promise<number> {
    const queryRunner = connection.createQueryRunner();
    const query = await queryRunner.query(
        `SELECT COUNT(*) AS [totalCount] FROM (${sql}) AS uniqueTableAlias`,
    );
    return query[0].totalCount;
}

/**
 * Returns a paginated object of Ts with pagination metadata
 * @param items array of T to paginate
 * @param totalItems total number of Ts
 * @param currentPage current page
 * @param limit Ts per page
 * @returns paginated array
 */
export function PaginateArray<T>(
    items: T[],
    totalItems: number,
    currentPage: number,
    limit: number,
) {
    return createPaginationObject<T>({
        items,
        totalItems,
        currentPage,
        limit,
    });
}
